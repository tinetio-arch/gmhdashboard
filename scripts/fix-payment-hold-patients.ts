#!/usr/bin/env npx tsx
/**
 * One-time remediation script for the payment hold loop bug.
 * 
 * This script:
 * 1. Finds patients on hold_payment_research with AUTO-SYNC spam notes
 * 2. Cleans the spam notes (removes hold/reactivate loop entries)
 * 3. Adds a single corrected summary note
 * 4. Reactivates patients who had successful "reactivated from hold" entries
 *    (meaning their payment DID succeed at some point)
 * 
 * Patients with ONLY failure entries (no reactivation) are flagged for manual review.
 * 
 * Run: npx tsx scripts/fix-payment-hold-patients.ts
 */

import dotenv from 'dotenv';
dotenv.config({ path: '/home/ec2-user/.env' });
dotenv.config({ path: '.env.local' });

import { query as dbQuery } from '../lib/db';

const DRY_RUN = process.argv.includes('--dry-run');

interface AffectedPatient {
    patient_id: string;
    full_name: string;
    notes: string;
    status_key: string;
}

// Lines generated by the cron loop bug
const AUTO_SYNC_PATTERNS = [
    /^\[[\d-]+\] AUTO-SYNC: Recurring payment failed:.*\(billingItem\)$/,
    /^\[[\d-]+\] AUTO-SYNC: Payment succeeded - reactivated from hold\.$/,
    /^\[[\d-]+\] AUTO-SYNC: Recurring payment FAILED -.*$/,
    /^\[[\d-]+\] AUTO-SYNC: One-time payment.*$/,
];

function isAutoSyncSpamLine(line: string): boolean {
    return AUTO_SYNC_PATTERNS.some(pattern => pattern.test(line.trim()));
}

function hasReactivationEntry(notes: string): boolean {
    return notes.includes('AUTO-SYNC: Payment succeeded - reactivated from hold.');
}

async function main() {
    console.log(`\n${'='.repeat(60)}`);
    console.log(`ğŸ”§ Payment Hold Loop Remediation Script`);
    console.log(`   Mode: ${DRY_RUN ? 'ğŸ” DRY RUN (no changes)' : 'âš¡ LIVE'}`);
    console.log(`${'='.repeat(60)}\n`);

    // Find all patients on hold with AUTO-SYNC entries
    const patients = await dbQuery<AffectedPatient>(`
        SELECT patient_id::text, full_name, notes, status_key
        FROM patients
        WHERE status_key = 'hold_payment_research'
          AND notes LIKE '%AUTO-SYNC%'
        ORDER BY full_name
    `);

    console.log(`ğŸ“‹ Found ${patients.length} patients on hold with AUTO-SYNC entries:\n`);

    const toReactivate: AffectedPatient[] = [];
    const manualReview: AffectedPatient[] = [];

    for (const patient of patients) {
        const lines = (patient.notes || '').split('\n');
        const spamLines = lines.filter(l => isAutoSyncSpamLine(l));
        const keepLines = lines.filter(l => !isAutoSyncSpamLine(l));
        const hadReactivation = hasReactivationEntry(patient.notes);

        console.log(`  ğŸ‘¤ ${patient.full_name}`);
        console.log(`     Total note lines: ${lines.length}`);
        console.log(`     Spam lines to remove: ${spamLines.length}`);
        console.log(`     Lines to keep: ${keepLines.length}`);
        console.log(`     Had successful reactivation: ${hadReactivation ? 'âœ… YES' : 'âŒ NO'}`);

        if (hadReactivation) {
            toReactivate.push(patient);
            console.log(`     â†’ Will REACTIVATE and clean notes\n`);
        } else {
            manualReview.push(patient);
            console.log(`     â†’ MANUAL REVIEW needed (no reactivation found)\n`);
        }
    }

    console.log(`\n${'='.repeat(60)}`);
    console.log(`ğŸ“Š Summary:`);
    console.log(`   Patients to reactivate: ${toReactivate.length}`);
    console.log(`   Patients for manual review: ${manualReview.length}`);
    console.log(`${'='.repeat(60)}\n`);

    if (DRY_RUN) {
        console.log('ğŸ” DRY RUN - no changes made. Run without --dry-run to apply.\n');
        return;
    }

    // Process patients to reactivate
    for (const patient of toReactivate) {
        const lines = (patient.notes || '').split('\n');
        const keepLines = lines.filter(l => !isAutoSyncSpamLine(l));

        // Find the earliest failure date for the summary
        const failureDates = lines
            .filter(l => l.includes('AUTO-SYNC: Recurring payment failed'))
            .map(l => {
                const match = l.match(/^\[(\d{4}-\d{2}-\d{2})\]/);
                return match ? match[1] : null;
            })
            .filter(Boolean)
            .sort();
        const earliestFailure = failureDates[0] || 'unknown';

        // Find the latest reactivation date for the summary
        const reactivationDates = lines
            .filter(l => l.includes('AUTO-SYNC: Payment succeeded - reactivated from hold'))
            .map(l => {
                const match = l.match(/^\[(\d{4}-\d{2}-\d{2})\]/);
                return match ? match[1] : null;
            })
            .filter(Boolean)
            .sort()
            .reverse();
        const latestReactivation = reactivationDates[0] || 'unknown';

        // Build corrected note
        const summaryLine = `[2026-02-17] AUTO-SYNC: Corrected - cron loop bug caused ${lines.length - keepLines.length} spam entries between ${earliestFailure} and today. Payment originally failed on ${earliestFailure}, patient paid successfully by ${latestReactivation}. Spam entries removed.`;

        const newNotes = [...keepLines, summaryLine].join('\n');

        await dbQuery(`
            UPDATE patients
            SET 
                status_key = 'active',
                alert_status = 'Active',
                notes = $2,
                last_modified = NOW()
            WHERE patient_id = $1
        `, [patient.patient_id, newNotes]);

        console.log(`  âœ… ${patient.full_name}: Reactivated, cleaned ${lines.length - keepLines.length} spam lines`);
    }

    // For manual review patients, still clean the spam but DON'T reactivate
    for (const patient of manualReview) {
        const lines = (patient.notes || '').split('\n');
        const keepLines = lines.filter(l => !isAutoSyncSpamLine(l));

        const failureDates = lines
            .filter(l => l.includes('AUTO-SYNC:'))
            .map(l => {
                const match = l.match(/^\[(\d{4}-\d{2}-\d{2})\]/);
                return match ? match[1] : null;
            })
            .filter(Boolean)
            .sort();
        const earliestFailure = failureDates[0] || 'unknown';

        const summaryLine = `[2026-02-17] AUTO-SYNC: Corrected - cron loop bug caused ${lines.length - keepLines.length} duplicate failure entries since ${earliestFailure}. Original failure is genuine (no successful payment found). Spam entries removed. STATUS KEPT ON HOLD - needs manual review.`;

        const newNotes = [...keepLines, summaryLine].join('\n');

        await dbQuery(`
            UPDATE patients
            SET 
                notes = $2,
                last_modified = NOW()
            WHERE patient_id = $1
        `, [patient.patient_id, newNotes]);

        console.log(`  âš ï¸  ${patient.full_name}: Notes cleaned (${lines.length - keepLines.length} spam lines removed), but KEPT ON HOLD for manual review`);
    }

    console.log(`\nğŸ‰ Remediation complete!`);
    console.log(`   ${toReactivate.length} patients reactivated`);
    console.log(`   ${manualReview.length} patients cleaned but kept on hold\n`);
}

main().catch(err => {
    console.error('âŒ Remediation failed:', err);
    process.exit(1);
});
